/* 
Drill 1
1) This would be O(1) since the yelling would
 theoretically reach everyone in the room, 
 as opposed to going up to each person and 
 asking them individually

2) This would be O(n) since the size of the 
 room would directly affect the runtime linearly


Drill 2
This would be O(1) since the algorithm only
accepts a single value, and the value itself
doesn't affect the runtime, it will either 
be even or odd

Drill 3
This would be O(n^2) due to the nested loops
of the algorithm. Increasing the input would
increase the runtime polynomially 

Drill 4
This would be O(n) since it would just grow
linearly if the input was increased.

Drill 5 
This would be O(n) since it is parsing through
each item in the array to check the match, thus
it would have a linear growth.

Drill 6
This would be O(n^2) due to the nested loops
causing a polynomial growth

Drill 7
This algorithm accepts a number value and then
it loops throuch each number starting from 1
up to the number that was passed through the 
function. If the number being valued is one,
it pushes a value of 0 to the result array,
and if the number is 2, it pushes a value of 1 
to the result array. Otherwise, other numbers
it calculates the fibonacci sequence of it and 
pushes it to the result array.
This would be a O(n) since the runtime would 
increase proportionally to the growth of the 
input

Drill 8
This algorithm is a O(logN) due to the efficency
of the algorithm. Because the algorithm always
narrows down the dataset to find the search,
increasing the input would increase the runtime,
but not increase it dramatically. The slight 
increase suggests a big O of O(logN)

Drill 9
This algorithm is an O(1) since the size of
the input doesn't really matter. The function
will always just find a random value and return it

Drill 10
This algorithm checks if a number is even,
and if it is, it checks if the numbers preceding it
is 
This algorithm would be O(n) since the size
of the input would increase the runtime proportionally


 */